<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>SSVEP – QWERTY Speller (Responsivo)</title>
<style>
  :root{
    --bg:#0a0b0e; --grid:#3c4147; --tile:#4a5159; --tileOn:#f1f5f9; --ink:#e9eef3;
    --pred:#60a5fa; --sel:#22c55e; --muted:#9aa4ad;
    --bw: clamp(2px,0.7vmin,6px);
    --barH: 56px;
    --fsKey: 32px;
  }
  *{ box-sizing:border-box }
  html,body{ height:100%; margin:0; background:var(--bg); color:var(--ink); font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; overflow:hidden; }
  #bar{
    display:flex; align-items:center; gap:12px; padding:10px 12px;
    border-bottom:1px solid #222831; flex-wrap:wrap;
  }
  #out{ font-weight:700; letter-spacing:.06em }
  #typed{ display:inline-block; min-width:10ch; word-break:break-all }
  .pill{ border:1px solid #2a3138; background:#0e1216; border-radius:999px; padding:4px 8px; color:var(--muted); font-size:12px }
  button{ background:#141a20; color:var(--ink); border:1px solid #26303a; padding:7px 12px; border-radius:8px; cursor:pointer }
  button:disabled{ opacity:.5; cursor:default }
  #stage{ color:var(--muted); font-size:12px }
  #kbd{
    width:100vw;
    height:calc(100vh - var(--barH));
    margin:0;
    display:grid; grid-template-rows:repeat(4,1fr);
    border:var(--bw) solid var(--grid); border-radius:8px; overflow:hidden;
  }
  .row{ display:grid; grid-template-columns:repeat(10,1fr); border-top:var(--bw) solid var(--grid) }
  .row:first-child{ border-top:0 }
  .key{
    display:grid; place-items:center; user-select:none; cursor:pointer;
    background:var(--tile); color:#fff; font-weight:700; letter-spacing:1px;
    border-left:var(--bw) solid var(--grid);
    transition:filter .06s linear, transform .06s ease, background .06s linear, color .06s;
    font-size:var(--fsKey);
  }
  .key:first-child{ border-left:0 }
  .key.on{ background:var(--tileOn); color:#111 }
  .key.pred{ outline:calc(var(--bw)*2) solid var(--pred); outline-offset:calc(-1*var(--bw)) }
  .key.sel{ outline:calc(var(--bw)*2) solid var(--sel); outline-offset:calc(-1*var(--bw)) }
  #hud{ position:fixed; left:12px; bottom:10px; display:flex; gap:8px; flex-wrap:wrap; color:var(--muted); font-size:12px }
</style>

<div id="bar">
  <div id="out">&gt; <span id="typed"></span></div>
  <button id="bStart">Start</button>
  <button id="bStop" disabled>Stop</button>
  <button id="bFS">Tela Cheia</button>
  <button id="bMode" title="T para alternar">Modo teste: OFF</button>
  <span class="pill">WS: <span id="ws">desconectado</span></span>
  <span class="pill">FPS: <span id="fps">…</span></span>
  <span id="gatePill" class="pill"></span>
  <span id="stage" class="pill">Fase: escolher <b>linha</b></span>
</div>

<div id="kbd"></div>
<div id="hud"></div>

<script>
/* ===== Layout ===== */
const ROWS = [
  ["1","2","3","4","5","6","7","8","9","0"],
  ["Q","W","E","R","T","Y","U","I","O","P"],
  ["A","S","D","F","G","H","J","K","L","\u2190"],
  ["Z","X","C","V","B","N","M",",","."]
];

/* ===== Config de modos ===== */
const CFG = {
  strict: { STABLE_MS:1200, REFRACTORY_MS:800, REL_TOL:0.08, AUTO_CONFIRM_DEADLINE_MS: Infinity },
  loose:  { STABLE_MS: 300, REFRACTORY_MS:250, REL_TOL:0.35, AUTO_CONFIRM_DEADLINE_MS: 1200 }
};
let MODE = "strict";
let STABLE_MS = CFG.strict.STABLE_MS;
let REFRACTORY_MS = CFG.strict.REFRACTORY_MS;
let REL_TOL = CFG.strict.REL_TOL;
let AUTO_CONFIRM_DEADLINE_MS = CFG.strict.AUTO_CONFIRM_DEADLINE_MS;

/* ===== Parâmetros de animação ===== */
let FPS = 60;
const ROW_PERIODS = [12, 8, 6, 4];          // ≈ [5, 7.5, 10, 15] Hz (a ~60 fps)
const KEY_PERIODS = [2,3,4,5,6,7,8,9,10,11];// até 10 teclas/linha

/* ===== Estado ===== */
const typedEl = document.getElementById('typed');
const kbd = document.getElementById('kbd');
const wsStateEl = document.getElementById('ws');
const fpsEl = document.getElementById('fps');
const stageEl = document.getElementById('stage');
const gatePill = document.getElementById('gatePill');
const hud = document.getElementById('hud');

let tiles=[], anim=0, running=false, ws=null, stage="row", rowIdx=0;
let lastGuess=null, stableSince=0, refractoryUntil=0, stageEnteredAt=0;
let autoTimer = null;

/* ===== Construção ===== */
function buildKeyboard(){
  kbd.innerHTML=''; tiles=[];
  for(let r=0;r<ROWS.length;r++){
    const row=document.createElement('div'); row.className='row';
    const cols=ROWS[r]; const N=Math.max(10,cols.length);
    row.style.gridTemplateColumns=`repeat(${N},1fr)`;
    for(let c=0;c<N;c++){
      const lab=cols[c]??''; const key=document.createElement('div');
      key.className='key'; key.textContent=lab;
      row.appendChild(key);
      tiles.push({el:key,row:r,col:c,label:lab,period:0,frame:0,active:false});
      key.onclick=()=>{
        if(!lab) return;
        if(stage==="row") enterKeyStage(r);
        else if(stage==="key"&&r===rowIdx&&c<ROWS[rowIdx].length) confirmSelection(lab);
      };
    }
    kbd.appendChild(row);
  }
  reflow();
}

/* ===== Responsividade ===== */
function reflow(){
  document.documentElement.style.setProperty('--barH', document.getElementById('bar').offsetHeight+'px');
  const any = kbd.querySelector('.key');
  if(any){
    const fs = Math.max(18, Math.min(any.clientWidth, any.clientHeight) * 0.55);
    document.documentElement.style.setProperty('--fsKey', fs+'px');
  }
}
window.addEventListener('resize', reflow);

/* ===== FPS ===== */
function measureFPS(durationMs=900){
  return new Promise(resolve=>{
    let frames=0, t0=null;
    const tick=(t)=>{ if(t0===null)t0=t; frames++; (t-t0<durationMs)?requestAnimationFrame(tick):resolve(frames*1000/(t-t0)); };
    requestAnimationFrame(tick);
  });
}

/* ===== Modo ===== */
function setMode(mode){
  MODE = mode;
  ({STABLE_MS, REFRACTORY_MS, REL_TOL, AUTO_CONFIRM_DEADLINE_MS} = CFG[MODE]);
  document.getElementById('bMode').textContent = `Modo teste: ${MODE==='loose'?'ON':'OFF'}`;
  gatePill.textContent = `Confirmação: ${STABLE_MS/1000}s • Refratário: ${REFRACTORY_MS/1000}s • Tol: ${(REL_TOL*100)|0}%`;
}
function toggleMode(){
  setMode(MODE==='strict'?'loose':'strict');
  // reinicia fase para aplicar imediatamente
  if(stage==='row') enterRowStage(); else enterKeyStage(rowIdx);
}

/* ===== Fases ===== */
function enterRowStage(){
  stage="row"; stageEl.innerHTML='Fase: escolher <b>linha</b>';
  lastGuess=null; stableSince=0; stageEnteredAt=performance.now();
  for(const t of tiles){
    t.active=(t.col < ROWS[t.row].length);
    t.period=ROW_PERIODS[t.row]||ROW_PERIODS.at(-1);
    t.frame=0; t.el.classList.remove('pred','sel','on');
  }
  scheduleAutoConfirm();
  reflow();
}
function enterKeyStage(r){
  rowIdx=r; stage="key"; stageEl.innerHTML=`Fase: escolher <b>tecla</b> — linha ${r+1}`;
  lastGuess=null; stableSince=0; stageEnteredAt=performance.now();
  for(const t of tiles){
    const inRow=(t.row===r)&&(t.col<ROWS[r].length);
    t.active=inRow; t.period=inRow?(KEY_PERIODS[t.col]||KEY_PERIODS.at(-1)):0;
    t.frame=0; if(!inRow) t.el.classList.remove('pred','sel','on');
  }
  scheduleAutoConfirm();
  reflow();
}

/* ===== Auto-confirmação (modo teste) ===== */
function getActiveTiles(){
  return tiles.filter(t=>t.active && t.label);
}
function randomChoice(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}
function scheduleAutoConfirm(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
  if(AUTO_CONFIRM_DEADLINE_MS===Infinity) return;
  autoTimer = setInterval(()=>{
    if(MODE!=='loose' || !running) return;
    const now=performance.now();
    if(now - stageEnteredAt >= AUTO_CONFIRM_DEADLINE_MS){
      const act = getActiveTiles();
      if(!act.length) return;
      // confirma aleatoriamente para demonstrar o fluxo
      if(stage==='row'){
        const pick = randomChoice(act);
        enterKeyStage(pick.row);
      }else{
        const inRow = act.filter(t=>t.row===rowIdx);
        const pick = randomChoice(inRow);
        confirmSelection(pick.label);
      }
    }
  }, 80);
}

/* ===== Animação ===== */
function loop(){
  for(const t of tiles){
    if(!t.active||!t.period){ t.el.classList.remove('on'); continue; }
    t.frame=(t.frame+1)%t.period;
    t.el.classList.toggle('on', t.frame < Math.floor(t.period/2));
  }
  anim=requestAnimationFrame(loop);
}

/* ===== WebSocket ===== */
function connectWS(){
  ws=new WebSocket("ws://127.0.0.1:8082/events");
  ws.onopen =()=> wsStateEl.textContent="conectado";
  ws.onclose=()=> wsStateEl.textContent="desconectado";
  ws.onmessage=(ev)=>{
    const msg=JSON.parse(ev.data);
    if(msg.type!=="prediction") return;
    const predHz=Number(msg.pred_hz ?? msg.pred ?? NaN);
    if(!isFinite(predHz)) return;
    handlePrediction(predHz);
  };
}

/* ===== Matching de frequência ===== */
function handlePrediction(predHz){
  const now=performance.now(); if(now<refractoryUntil) return;

  // melhor tile por proximidade
  let best=null, bestDiff=Infinity, bestF=null;
  for(const t of tiles){
    if(!t.active||!t.period) continue;
    const f=FPS/t.period, d=Math.abs(predHz - f);
    if(d<bestDiff){ bestDiff=d; best=t; bestF=f; }
  }
  if(!best) return;

  const withinTol = (Math.abs(predHz-bestF) <= REL_TOL*bestF);
  const ok = MODE==='loose' ? (withinTol || true) : withinTol; // no modo teste aceita sempre o melhor

  for(const t of tiles){ t.el.classList.toggle('pred', t===best && ok); }
  const guess = ok ? (stage==="row" ? `row:${best.row}` : best.label) : null;

  if(guess && guess===lastGuess){
    if(!stableSince) stableSince=now;
    if(now-stableSince >= STABLE_MS){
      if(stage==="row") enterKeyStage(best.row);
      else confirmSelection(best.label);
      refractoryUntil=now+REFRACTORY_MS; stableSince=0; lastGuess=null;
      stageEnteredAt = performance.now(); // reinicia deadline da fase seguinte
    }
  }else{
    lastGuess=guess;
    stableSince=guess?now:0;
  }
}

/* ===== Seleção ===== */
function confirmSelection(label){
  const t=tiles.find(x=>x.active&&x.label===label&&x.row===rowIdx);
  if(t){ t.el.classList.add('sel'); setTimeout(()=>t.el.classList.remove('sel'), 220); }
  if(label==="\u2190") typedEl.textContent=typedEl.textContent.slice(0,-1);
  else typedEl.textContent+=label;
  enterRowStage();
}

/* ===== Controles ===== */
async function start(){
  if(running) return; running=true;
  bStart.disabled=true; bStop.disabled=false;
  FPS=Math.round(await measureFPS(900)); fpsEl.textContent=FPS.toString();
  enterRowStage(); loop(); if(!ws || ws.readyState>1) connectWS();
  updateHUD();
}
function stop(){
  if(!running) return; running=false;
  cancelAnimationFrame(anim); bStart.disabled=false; bStop.disabled=true;
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; }
  for(const t of tiles){ t.el.classList.remove('on','pred','sel'); t.active=false; t.period=0; }
}
function updateHUD(){
  hud.innerHTML='';
  const mk=txt=>{ const s=document.createElement('span'); s.className='pill'; s.textContent=txt; return s; };
  hud.append(mk(`Modo: ${MODE==='loose'?'TESTE (afrouxado)':'RÍGIDO'}`));
  hud.append(mk(`Linhas (Hz): ${ROW_PERIODS.map(p=>(FPS/p).toFixed(2)).join(', ')}`));
  hud.append(mk(`Teclas (Hz): ${KEY_PERIODS.map(p=>(FPS/p).toFixed(2)).join(', ')}`));
  gatePill.textContent = `Confirmação: ${STABLE_MS/1000}s • Refratário: ${REFRACTORY_MS/1000}s • Tol: ${(REL_TOL*100)|0}%`;
}

const bStart=document.getElementById('bStart');
const bStop =document.getElementById('bStop');
const bMode =document.getElementById('bMode');
bStart.onclick=start; bStop.onclick=stop; bMode.onclick=()=>{ toggleMode(); updateHUD(); };

// Toggle por teclado
window.addEventListener('keydown', (e)=>{
  if(e.key.toLowerCase()==='t'){ toggleMode(); updateHUD(); }
});

// Tela cheia
document.getElementById('bFS').onclick=()=>{
  const el=document.documentElement;
  if(!document.fullscreenElement) el.requestFullscreen?.();
  else document.exitFullscreen?.();
};

// boot
buildKeyboard();
setMode('strict'); // começa rígido
reflow();
</script>
